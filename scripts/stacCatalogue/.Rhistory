}
lon = "lon"
lat="lat"
if (use.obs) {
if (inherits(obs, "data.frame")) {
# Reproject the obs to the data cube projection
proj.pts <- project_coords(obs, lon = lon, lat = lat, proj_from = srs.cube)
} else {
proj.pts <- obs
}
# Create the extent (data cube projection)
bbox.proj <- points_to_bbox(proj.pts, buffer = buffer.box)
left <- bbox.proj$xmin
right <- bbox.proj$xmax
bottom <- bbox.proj$ymin
top <- bbox.proj$ymax
# Create the bbxo (WGS84 projection)
bbox.wgs84 <- bbox.proj %>%
sf::st_bbox(crs = srs.cube) %>%
sf::st_as_sfc() %>%
sf::st_transform(crs = 4326) %>%
sf::st_bbox()
} else {
bbox.proj <- bbox
left <- bbox.proj$xmin
right <- bbox.proj$xmax
bottom <- bbox.proj$ymin
top <- bbox.proj$ymax
if (left > right) stop("left and right seem reversed")
if (bottom > top) stop("bottom and top seem reversed")
bbox.wgs84 <- c(left,
right,
top,
bottom) %>%
sf::st_bbox(crs = srs.cube) %>%
sf::st_as_sfc() %>%
sf::st_transform(crs = 4326) %>%
sf::st_bbox()
}
bbox.wgs84
bbox.proj
it_obj <- s |>
stac_search(bbox = bbox.wg84, collections = collections, limit = limit) |> get_request() # bbox in decimal lon/lat
it_obj <- s |>
stac_search(bbox = bbox.wgs84, collections = collections, limit = limit) |> get_request() # bbox in decimal lon/lat
all.layers <- unlist(lapply(it_obj$features,function(x){names(x$assets)}))
st <- stac_image_collection(it_obj$features, asset_names = all.layers,
property_filter = function(x) {x[["variable"]] %in% layers & x[["time_span"]] == time.span  & x[["rcp"]] == rcp })
get_info_collection(stac_path =
"http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c('chelsa-clim-proj'),
bbox = NULL)
load_cube_projection <- function(stac_path =
"http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c('chelsa-clim-proj'),
use.obs = T,
obs = NULL,
lon = "lon",
lat = "lat",
buffer.box = 0,
bbox = NULL,
layers = NULL,
variable = NULL,
srs.cube = "EPSG:32198",
time.span = "2041-2070",
rcp = "ssp585",
left = -2009488, right = 1401061,  bottom = -715776, top = 2597757,
spatial.res = 2000,
temporal.res  = "P1Y", aggregation = "mean",
resampling = "near") {
#t0 param
if (time.span == "2041-2070") {
t0 <- "2041-01-01"
}
if (time.span == "2071-2100") {
t0 <- "2071-01-01"
}
s <- stac(stac_path)
if (use.obs) {
if (inherits(obs, "data.frame")) {
# Reproject the obs to the data cube projection
proj.pts <- project_coords(obs, lon = lon, lat = lat, proj_from = srs.cube)
} else {
proj.pts <- obs
}
# Create the extent (data cube projection)
bbox.proj <- points_to_bbox(proj.pts, buffer = buffer.box)
left <- bbox.proj$xmin
right <- bbox.proj$xmax
bottom <- bbox.proj$ymin
top <- bbox.proj$ymax
# Create the bbxo (WGS84 projection)
bbox.wgs84 <- bbox.proj %>%
sf::st_bbox(crs = srs.cube) %>%
sf::st_as_sfc() %>%
sf::st_transform(crs = 4326) %>%
sf::st_bbox()
} else {
bbox.proj <- bbox
left <- bbox.proj$xmin
right <- bbox.proj$xmax
bottom <- bbox.proj$ymin
top <- bbox.proj$ymax
if (left > right) stop("left and right seem reversed")
if (bottom > top) stop("bottom and top seem reversed")
bbox.wgs84 <- c(left,
right,
top,
bottom) %>%
sf::st_bbox(crs = srs.cube) %>%
sf::st_as_sfc() %>%
sf::st_transform(crs = 4326) %>%
sf::st_bbox()
}
it_obj <- s |>
stac_search(bbox = bbox.wgs84, collections = collections, limit = limit) |> get_request() # bbox in decimal lon/lat
# If no layers is selected, get all the layers by default
if (is.null(layers)) {
layers <- unlist(lapply(it_obj$features, function(x){names(x$assets)}))
}
#
# Creates an image collection
if(!is.null(variable)) {
st <- gdalcubes::stac_image_collection(it_obj$features, asset_names = layers,
property_filter = function(x) {x[["variable"]] %in% variable})
} else {
st <- gdalcubes::stac_image_collection(it_obj$features, asset_names = layers)
}
#if layers = NULL, load all the layers
v <- cube_view(srs = srs.cube,  extent = list(t0 = t0, t1 = t0,
left = left, right = right,  top = top, bottom = bottom),
dx = spatial.res, dy = spatial.res, dt = temporal.res, aggregation = aggregation, resampling = resampling)
gdalcubes_options(threads = 4)
cube <- raster_cube(st, v)
return(cube)
}
cube.future <- load_cube_projection(stac_path =
"http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c('chelsa-clim-proj'),
use.obs = T,
obs = obs.coords.proj,
buffer.box = 0,
rcp = 'ssp126', #ssp126, ssp370, ssp585
bbox = NULL, #layers = layers,
srs.cube = srs.cube,
time.span = "2041-2070", #2041-2070 or 2071-2100
spatial.res = 1000,
temporal.res  = "P1Y",
aggregation = "mean",
resampling = "near")
cube
cube.future
cube.future <- load_cube_projection(stac_path =
"http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c('chelsa-clim-proj'),
use.obs = T,
obs = obs.coords.proj,
buffer.box = 0,
rcp = 'ssp126', #ssp126, ssp370, ssp585
bbox = NULL, #layers = layers,
srs.cube = srs.cube,
variable = "bio1",
time.span = "2041-2070", #2041-2070 or 2071-2100
spatial.res = 1000,
temporal.res  = "P1Y",
aggregation = "mean",
resampling = "near")
cube.future
it_obj
it_obj$features
load_cube_projection <- function(stac_path =
"http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c('chelsa-clim-proj'),
use.obs = T,
obs = NULL,
lon = "lon",
lat = "lat",
buffer.box = 0,
bbox = NULL,
layers = NULL,
variable = NULL,
srs.cube = "EPSG:32198",
time.span = "2041-2070",
rcp = "ssp585",
left = -2009488, right = 1401061,  bottom = -715776, top = 2597757,
spatial.res = 2000,
temporal.res  = "P1Y", aggregation = "mean",
resampling = "near") {
#t0 param
if (time.span == "2041-2070") {
t0 <- "2041-01-01"
}
if (time.span == "2071-2100") {
t0 <- "2071-01-01"
}
s <- stac(stac_path)
if (use.obs) {
if (inherits(obs, "data.frame")) {
# Reproject the obs to the data cube projection
proj.pts <- project_coords(obs, lon = lon, lat = lat, proj_from = srs.cube)
} else {
proj.pts <- obs
}
# Create the extent (data cube projection)
bbox.proj <- points_to_bbox(proj.pts, buffer = buffer.box)
left <- bbox.proj$xmin
right <- bbox.proj$xmax
bottom <- bbox.proj$ymin
top <- bbox.proj$ymax
# Create the bbxo (WGS84 projection)
bbox.wgs84 <- bbox.proj %>%
sf::st_bbox(crs = srs.cube) %>%
sf::st_as_sfc() %>%
sf::st_transform(crs = 4326) %>%
sf::st_bbox()
} else {
bbox.proj <- bbox
left <- bbox.proj$xmin
right <- bbox.proj$xmax
bottom <- bbox.proj$ymin
top <- bbox.proj$ymax
if (left > right) stop("left and right seem reversed")
if (bottom > top) stop("bottom and top seem reversed")
bbox.wgs84 <- c(left,
right,
top,
bottom) %>%
sf::st_bbox(crs = srs.cube) %>%
sf::st_as_sfc() %>%
sf::st_transform(crs = 4326) %>%
sf::st_bbox()
}
it_obj <- s |>
stac_search(bbox = bbox.wgs84, collections = collections, limit = limit) |> get_request() # bbox in decimal lon/lat
# If no layers is selected, get all the layers by default
if (is.null(layers)) {
layers <- unlist(lapply(it_obj$features, function(x){names(x$assets)}))
}
#
# Creates an image collection
if(!is.null(variable)) {
st <- gdalcubes::stac_image_collection(it_obj$features, asset_names = layers,
property_filter = function(x) {x[["variable"]] %in% variable & x[["rcp"]] == rcp})
} else {
st <- gdalcubes::stac_image_collection(it_obj$features, asset_names = layers,
property_filter = function(x) {x[["rcp"]] == rcp})
}
#if layers = NULL, load all the layers
v <- cube_view(srs = srs.cube,  extent = list(t0 = t0, t1 = t0,
left = left, right = right,  top = top, bottom = bottom),
dx = spatial.res, dy = spatial.res, dt = temporal.res, aggregation = aggregation, resampling = resampling)
gdalcubes_options(threads = 4)
cube <- raster_cube(st, v)
return(cube)
}
cube.future <- load_cube_projection(stac_path =
"http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c('chelsa-clim-proj'),
use.obs = T,
obs = obs.coords.proj,
buffer.box = 0,
rcp = 'ssp126', #ssp126, ssp370, ssp585
bbox = NULL, #layers = layers,
srs.cube = srs.cube,
variable = "bio1",
time.span = "2041-2070", #2041-2070 or 2071-2100
spatial.res = 1000,
temporal.res  = "P1Y",
aggregation = "mean",
resampling = "near")
cube
cube.future
get_info_collection(stac_path =
"http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c('chelsa-clim-proj'),
bbox = NULL)
load_cube_projection <- function(stac_path =
"http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c('chelsa-clim-proj'),
use.obs = T,
obs = NULL,
lon = "lon",
lat = "lat",
buffer.box = 0,
bbox = NULL,
layers = NULL,
variable = NULL,
srs.cube = "EPSG:32198",
time.span = "2041-2070",
rcp = "ssp585",
left = -2009488, right = 1401061,  bottom = -715776, top = 2597757,
spatial.res = 2000,
temporal.res  = "P1Y", aggregation = "mean",
resampling = "near") {
#t0 param
if (time.span == "2011-2040") {
t0 <- "2011-01-01"
}
if (time.span == "2041-2070") {
t0 <- "2041-01-01"
}
if (time.span == "2071-2100") {
t0 <- "2071-01-01"
}
datetime <- format(lubridate::as_datetime(t0), "%Y-%m-%dT%H:%M:%SZ")
s <- stac(stac_path)
if (use.obs) {
if (inherits(obs, "data.frame")) {
# Reproject the obs to the data cube projection
proj.pts <- project_coords(obs, lon = lon, lat = lat, proj_from = srs.cube)
} else {
proj.pts <- obs
}
# Create the extent (data cube projection)
bbox.proj <- points_to_bbox(proj.pts, buffer = buffer.box)
left <- bbox.proj$xmin
right <- bbox.proj$xmax
bottom <- bbox.proj$ymin
top <- bbox.proj$ymax
# Create the bbxo (WGS84 projection)
bbox.wgs84 <- bbox.proj %>%
sf::st_bbox(crs = srs.cube) %>%
sf::st_as_sfc() %>%
sf::st_transform(crs = 4326) %>%
sf::st_bbox()
} else {
bbox.proj <- bbox
left <- bbox.proj$xmin
right <- bbox.proj$xmax
bottom <- bbox.proj$ymin
top <- bbox.proj$ymax
if (left > right) stop("left and right seem reversed")
if (bottom > top) stop("bottom and top seem reversed")
bbox.wgs84 <- c(left,
right,
top,
bottom) %>%
sf::st_bbox(crs = srs.cube) %>%
sf::st_as_sfc() %>%
sf::st_transform(crs = 4326) %>%
sf::st_bbox()
}
it_obj <- s |>
stac_search(bbox = bbox.wgs84, collections = collections, limit = limit, datetime = datetime) |> get_request() # bbox in decimal lon/lat
# If no layers is selected, get all the layers by default
if (is.null(layers)) {
layers <- unlist(lapply(it_obj$features, function(x){names(x$assets)}))
}
#
# Creates an image collection
if(!is.null(variable)) {
st <- gdalcubes::stac_image_collection(it_obj$features, asset_names = layers,
property_filter = function(x) {x[["variable"]] %in% variable & x[["rcp"]] == rcp})
} else {
st <- gdalcubes::stac_image_collection(it_obj$features, asset_names = layers,
property_filter = function(x) {x[["rcp"]] == rcp})
}
#if layers = NULL, load all the layers
v <- cube_view(srs = srs.cube,  extent = list(t0 = t0, t1 = t0,
left = left, right = right,  top = top, bottom = bottom),
dx = spatial.res, dy = spatial.res, dt = temporal.res, aggregation = aggregation, resampling = resampling)
gdalcubes_options(threads = 4)
cube <- raster_cube(st, v)
return(cube)
}
cube.future <- load_cube_projection(stac_path =
"http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c('chelsa-clim-proj'),
use.obs = T,
obs = obs.coords.proj,
buffer.box = 0,
rcp = 'ssp126', #ssp126, ssp370, ssp585
bbox = NULL, #layers = layers,
srs.cube = srs.cube,
variable = "bio1",
time.span = "2041-2070", #2041-2070 or 2071-2100
spatial.res = 1000,
temporal.res  = "P1Y",
aggregation = "mean",
resampling = "near")
cube.future
value.points.future <- extract_geom(cube.future, sf::st_as_sf(obs.coords.proj, coords = c("lon", "lat"),
crs = srs.cube))
value.points.future <- dplyr::bind_cols(data.frame(obs.coords.proj),
value.points.future) %>% dplyr::rename(id = FID)
head(value.points.future)
View(value.points.future)
cube <-
load_cube(stac_path = "http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c("esacci-lc"),
use.obs = T,
obs = obs,
buffer.box = 0,
srs.cube = srs.cube,
t0 = NULL,
t1 = NULL,
spatial.res = 1000, # in meters
temporal.res =  "P1Y",
aggregation = "mean",
resampling = "near")
cube <-
load_cube(stac_path = "http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c("esacci-lc"),
use.obs = T,
obs = obs.coords.proj,
buffer.box = 0,
srs.cube = srs.cube,
t0 = NULL,
t1 = NULL,
spatial.res = 1000, # in meters
temporal.res =  "P1Y",
aggregation = "mean",
resampling = "near")
plot(cube %>% select_bands("esacci-lc-2000"))
cube
cube <-
load_cube(stac_path = "http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c("esacci-lc"),
use.obs = T,
obs = obs.coords.proj,
buffer.box = 0,
srs.cube = srs.cube,
t0 = "2000-01-01",
t1 = NULL,
spatial.res = 1000, # in meters
temporal.res =  "P1Y",
aggregation = "mean",
resampling = "near")
cube <-
load_cube(stac_path = "http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c("esacci-lc"),
use.obs = T,
obs = obs.coords.proj,
buffer.box = 0,
srs.cube = srs.cube,
t0 = "2000-01-01",
t1 = "2000-12-31",
spatial.res = 1000, # in meters
temporal.res =  "P1Y",
aggregation = "mean",
resampling = "near")
plot(cube %>% select_bands("esacci-lc-2000"))
install.packages("highr")
renv::init()
knitr::opts_chunk$set(echo = TRUE)
library("gdalcubes")
library("rstac")
library("tibble")
library("sp")
library("sf")
library("dplyr")
library("rgbif")
library("tidyr")
library("stars")
source("stac_functions.R")
stac("http://io.biodiversite-quebec.ca/stac/") %>%
collections() %>%
get_request()
obs <- rgbif::occ_data(scientificName = "Glyptemys insculpta", hasCoordinate = TRUE, limit = 1000)
obs <- dplyr::select(obs$data, decimalLongitude, decimalLatitude) %>%
dplyr::rename(lon = decimalLongitude) %>%
dplyr::rename(lat = decimalLatitude)
head(obs)
srs.obs <-"EPSG:4326" # initial observations projection system
srs.cube <- "EPSG:6623" # targeted projected projection system
obs.coords.proj <- create_projection(obs, lon = "lon", lat = "lat",
srs.obs, srs.cube)
cube <-
load_cube(stac_path = "http://io.biodiversite-quebec.ca/stac/",
limit = 5000,
collections = c("chelsa-monthly"),
use.obs = T,
obs = obs.coords.proj,
buffer.box = 0,
srs.cube = srs.cube,
t0 = "2016-01-01",
t1 = "2016-03-01",
variable = "tasmax",
spatial.res = 1000, # in meters
temporal.res = "P1Y",
aggregation = "mean",
resampling = "near")
values <- gdalcubes::extract_geom(cube, sf::st_as_sf(obs.coords.proj, coords = c("lon", "lat"),
crs = srs.cube)) %>% dplyr::select(-time)
head(values)
values <- values %>% dplyr::mutate(mean_manual = rowMeans(select(values, starts_with("tasmax"))))
sum_bands <-  paste(names(cube), collapse="+")
mean_bands <- sprintf("(%s)/%i", sum_bands, length(names(cube)))
mean_bands
# apply to each pixel the next function
tmean_cube <- apply_pixel(cube, mean_bands, names = "mean_tmean")
tmean_cube <- apply_pixel(cube, mean_bands, names = "mean_tmean")
values.auto <- gdalcubes::extract_geom(tmean_cube, sf::st_as_sf(obs.coords.proj, coords = c("lon", "lat"),
crs = srs.cube)) %>% dplyr::select(-time)
values <- dplyr::left_join(values, values.auto, by = "FID")
View(values)
devtools::install_github("appelmar/gdalcubes_R")
install.packages("gdalcubes")
library(gdalcubes)

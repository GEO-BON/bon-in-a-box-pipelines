#### Load required packages - libraries to run the script ####

# Install necessary libraries - packages  
packagesPrev<- installed.packages()[,"Package"] # Check and get a list of installed packages in this machine and R version
packagesNeed<- c("magrittr", "terra", "raster", "sf", "pbapply", "this.path", "rjson", "auk") # Define the list of required packages to run the script
new.packages <- packagesNeed[!(packagesNeed %in% packagesPrev)]; if(length(new.packages)) {install.packages(new.packages, binary=T, force=T, dependencies = F, repos= "https://packagemanager.posit.co/cran/__linux__/jammy/latest")} # Check and install required packages that are not previously installed

# Load libraries
packagesList<-list("magrittr", "terra") # Explicitly list the required packages throughout the entire routine. Explicitly listing the required packages throughout the routine ensures that only the necessary packages are listed. Unlike 'packagesNeed', this list includes packages with functions that cannot be directly called using the '::' syntax. By using '::', specific functions or objects from a package can be accessed directly without loading the entire package. Loading an entire package involves loading all the functions and objects 
lapply(packagesList, library, character.only = TRUE)  # Load libraries - packages  







Sys.setenv(outputFolder = "/path/to/output/folder")

# Option 2: Recommended for debugging purposes to be used as a testing environment. This is designed to facilitate script testing and correction
if ( (!exists("outputFolder"))  ) {
  outputFolder<- {x<- this.path::this.path();  file_prev<-  paste0(gsub("/scripts.*", "/output", x), gsub("^.*/scripts", "", x)  ); options<- tools::file_path_sans_ext(file_prev) %>% {c(., paste0(., ".R"), paste0(., "_R"))}; folder_out<- options %>% {.[file.exists(.)]} %>% {.[which.max(sapply(., function(info) file.info(info)$mtime))]}; folder_final<- list.files(folder_out, full.names = T) %>% {.[which.max(sapply(., function(info) file.info(info)$mtime))]} }
}

# Set the 'input' environment variables. The 'input' environment contains the specified inputs from the ByB platform.
# The input file 'input.json' is generated by executing the 'Run Script' command in the ByB platform.
input <- rjson::fromJSON(file=file.path(outputFolder, "input.json")) # Load input file

# This section adjusts the input values based on specific conditions to rectify and prevent errors in the input paths
input<- lapply(input, function(x) { if (!is.null(x) && length(x) > 0 && grepl("/", x) && !grepl("http://", x)  ) { 
  sub("/output/.*", "/output", outputFolder) %>% dirname() %>%  file.path(x) %>% {gsub("//+", "/", .)}  } else{x} }) 





output<- (function(){

### tenemos que poner un condicional que pruebe y transforme en 4326
study_area<- terra::rast(input$studyarea) %>% terra::project(terra::crs( "+proj=longlat +datum=WGS84 +no_defs" )) # cargar raster
bbox_studyarea<- terra::ext(study_area) %>% sf::st_bbox()

####  Script body ####

# Precargar datos de ocurrencia y listas
#Definir rutas donde se van a guardar archivos
ebd <- auk::auk_ebd(file= input$ebd_file,  file_sampling = input$ebd_sampling_file) # precargar datos



# Definri filtros de datos de mi especie de interes
ebd_filters <- ebd %>% auk::auk_species(input$sp) %>% # filtrar por especies de interes
  auk::auk_protocol(protocol = c("Stationary", "Traveling"))  %>% # filtro por portocolo - Metodologia de muestreoo. 
  auk::auk_country("CO") %>% # Filtro por pais
  auk::auk_bbox(bbox_studyarea) %>%  # Filtrar por extension geografica
  #auk_state(state = "CALDAS") # Filtrar por jurisdiccion
  auk::auk_complete() # Filtrar solo listas completas


# Aplicar los filtros denifidos y exportar archivos (sp_ebd****.txt y sp_ebd_sampling****.txt) de la especie de interes
dir_ebdfile<- file.path(outputFolder, paste0(paste(c("ebdfile", input$sp, round(bbox_studyarea)), collapse = "_"), ".txt")) # Define the file path for the 'val_wkt_path' output
dir_ebd_sampling_file<- file.path(outputFolder, paste0(paste(c("ebd_sampling_file", input$sp, round(bbox_studyarea)), collapse = "_"), ".txt")) # Define the file path for the 'val_wkt_path' output



# generar archivo filtro

auk::auk_filter(x= ebd_filters, file = dir_ebdfile, file_sampling = dir_ebd_sampling_file, overwrite = TRUE)






# funcion para cambiar la hora a decimal
time_to_decimal <- function(x) {x <- lubridate::hms(x, quiet = TRUE); lubridate::hour(x) + lubridate::minute(x) / 60 + lubridate::second(x) / 3600} # function para convertir fechas en decimales
# Unir (sp_ebd****.txt y sp_ebd_sampling****.txt) y agrega columna de presencia y ausencio de la sp por lista (zero-filling) 
pre_ebd_zf <- tryCatch({  auk::auk_zerofill(x= dir_ebdfile, sampling_events =  dir_ebd_sampling_file, collapse = TRUE) }, error=function(e) {NULL} )


if(is.null(pre_ebd_zf)){return("Error: Los parametros definidos generan un filtro vacio")} # mensaje, la url no existe



# Limpiar ebd_zf - estandarizar datos
ebd_zf <- pre_ebd_zf  %>% dplyr::mutate(effort_distance_km= as.numeric(effort_distance_km)) %>% 
  dplyr::rowwise() %>%
  dplyr::mutate(observation_count = if(observation_count %in% "X"){NA}else{observation_count}) %>%  # Convertir en observation_count X observaciones en NA
  dplyr::mutate(observation_count = as.integer(observation_count),
                year = lubridate::year(observation_date),# crrear columna a√±o
                day_of_year = lubridate::yday(observation_date),
                effort_distance_km = dplyr::if_else(protocol_type != "Traveling", 0, effort_distance_km) # effort_distance_km to 0 for non-travelling counts
                )
ebd_zf$time_observations_started<- time_to_decimal(ebd_zf$time_observations_started)  # convertir fechas en decimales
  

# Filtros por esfuerzo de muestreo - Optimizacion de la variacion en la detectabilidad
ebd_zf_filtered <- ebd_zf %>% 
  dplyr::filter(duration_minutes <= 5 * 60, effort_distance_km <= 10, # effort filters
         year >= 2010, # filtro por rango temporal
         number_observers <= 10) # filtro por numero de observadores


# Definir ruta de salida de los arcivos zero_fill  la especie de interes
dir_ebd_zerofill<- file.path(outputFolder, paste0(paste(c("zf_ebdfile", input$sp, round(bbox_studyarea)), collapse = "_"), ".txt")) # 

ebird <- ebd_zf_filtered %>% 
  dplyr::select(checklist_id, observer_id, sampling_event_identifier,
                scientific_name, observation_count, species_observed, 
                state_code, locality_id, latitude, longitude,
                protocol_type, all_species_reported,
                observation_date,  year, day_of_year,
                time_observations_started, 
                duration_minutes, effort_distance_km,
                number_observers)

write.table(ebird, dir_ebd_zerofill, sep = "\t", row.names = FALSE, quote = T) ## exportar zf

output<- list(ebd_zerofill = dir_ebd_zerofill, ebd_filter= dir_ebdfile, ebd_sampling_filter= dir_ebd_sampling_file)

})()


#### Outputing result to JSON ####

# Write the output list to the 'output.json' file in JSON format
setwd(outputFolder)
jsonlite::write_json(output, "output.json", auto_unbox = TRUE, pretty = TRUE)
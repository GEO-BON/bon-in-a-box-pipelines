#### Load required packages - libraries to run the script ####

# Install necessary libraries - packages  
packagesPrev<- installed.packages()[,"Package"] # Check and get a list of installed packages in this machine and R version
packagesNeed<- list("magrittr", "terra", "raster", "sf", "fasterize", "pbapply", "this.path", "rjson") # Define the list of required packages to run the script
lapply(packagesNeed, function(x) {   if ( ! x %in% packagesPrev ) { install.packages(x, force=F)}    }) # Check and install required packages that are not previously installed

# Load libraries
packagesList<-list("magrittr", "terra") # Explicitly list the required packages throughout the entire routine. Explicitly listing the required packages throughout the routine ensures that only the necessary packages are listed. Unlike 'packagesNeed', this list includes packages with functions that cannot be directly called using the '::' syntax. By using '::', specific functions or objects from a package can be accessed directly without loading the entire package. Loading an entire package involves loading all the functions and objects 
lapply(packagesList, library, character.only = TRUE)  # Load libraries - packages  


#### Set enviroment variables ###
# Option 1: Setting for production pipeline purposes. This is designed for use in a production environment or workflow.
Sys.setenv(outputFolder = "/path/to/output/folder")

# Option 2: Recommended for debugging purposes to be used as a testing environment. This is designed to facilitate script testing and correction
if ( (!exists("outputFolder"))  ) {
  outputFolder<- {x<- this.path::this.path();  file_prev<-  paste0(gsub("/scripts.*", "/output", x), gsub("^.*/scripts", "", x)  ); options<- tools::file_path_sans_ext(file_prev) %>% {c(., paste0(., ".R"), paste0(., "_R"))}; folder_out<- options %>% {.[file.exists(.)]} %>% {.[which.max(sapply(., function(info) file.info(info)$mtime))]}; folder_final<- list.files(folder_out, full.names = T) %>% {.[which.max(sapply(., function(info) file.info(info)$mtime))]} }
}

# Set the 'input' environment variables. The 'input' environment contains the specified inputs from the ByB platform.
# The input file 'input.json' is generated by executing the 'Run Script' command in the ByB platform.
input <- rjson::fromJSON(file=file.path(outputFolder, "input.json")) # Load input file

# This section adjusts the input values based on specific conditions to rectify and prevent errors in the input paths
input<- lapply(input, function(x) { if (!is.null(x) && length(x) > 0 && grepl("/", x) && !grepl("http://", x)  ) { 
  sub("/output/.*", "/output", outputFolder) %>% dirname() %>%  file.path(x) %>% {gsub("//+", "/", .)}  } else{x} }) 


####  Script body ####
output<- (function(){
  
  
  
  # Load and convert the study area to aggregate polygon limits and project it to the defined EPSG coordinate system
  crs_basemap<- raster::crs( paste0("+init=epsg:", input$studyarea_epsg) )
  
  vector_polygon<-  terra::vect(input$studyarea_path) %>% terra::aggregate()  %>%  terra::project( crs_basemap    )
  
  # Convert the vector polygon to the GeoJSON format and transform its coordinate reference system to 4326 (WGS84) to make it compatible with the Leaflet interactive JavaScript library
  sf_polygon<- sf::st_as_sf(vector_polygon) 
  sf_polygon_4326<- sf_polygon %>% sf::st_transform(4326)
  
  # Create bbox reference
  bbox_base<- sf_polygon  %>% sf::st_bbox() 
  extent_base <- bbox_base %>% raster::extent()
  
  
  # create base grid
  raster_base <- raster::raster(extent_base,crs = crs_basemap, res= input$studyarea_resolution )
  raster_study_area<- fasterize::fasterize(sf_polygon, raster_base) %>% terra::rast()
  
  levels(raster_study_area)<- data.frame(values= 1, label= "Study area")
  coltab(raster_study_area)<- data.frame(values= 1, cols= "gray")
  
  
  # Define and export the output values
  # Define raster_study_area_path path
  raster_study_area_path<- file.path(outputFolder, "raster_study_area_path.tif") # Define the file path for the 'val_wkt_path' output
  terra::writeRaster(raster_study_area, raster_study_area_path, gdal=c("COMPRESS=DEFLATE", "TFW=YES"), filetype = "GTiff", overwrite = TRUE )

  
  
  json_study_area_path<- file.path(outputFolder, "json_study_area_path.GeoJSON") # Define the file path for the 'val_wkt_path' output
  sf::st_write(sf_polygon_4326, json_study_area_path, delete_dsn= T, driver = "GeoJSON")

  
  # Define final output list
  output<- list(original_area= json_study_area_path, study_area_path= raster_study_area_path)

})()




#### Outputing result to JSON ####

# Write the output list to the 'output.json' file in JSON format
setwd(outputFolder)
jsonlite::write_json(output, "output.json", auto_unbox = TRUE, pretty = TRUE)
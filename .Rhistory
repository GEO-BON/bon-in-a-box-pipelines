)
}, bg.border = NA) # here set bg.border to NA is important
for(i in 1:length(df.group$Group)){
g = df.group$Group[i]
highlight.sector(sector.index = df.group$Var[which(df.group$Group == g)], track.index = 3, col = grid.col.for.group[i], text = g, cex = 0.6, text.col = "black")
}
dev.off()
circos.clear()
group
group[levels]
i
View(df.links)
colors.for.group
create.chord.diagram(padiweb.links.filepath, padiweb.output.filepath, padiweb.legend.filepath,
colors.for.group, colors.for.geo.focus, colors.for.specialization, small.gap,
big.gap, )
create.chord.diagram(padiweb.links.filepath, padiweb.output.filepath, padiweb.legend.filepath,
colors.for.group, colors.for.geo.focus, colors.for.specialization, small.gap,
big.gap)
dev.off()
create.chord.diagram(healthmap.links.filepath, healthmap.output.filepath, healthmap.legend.filepath, colors.for.group, colors.for.geo.focus, colors.for.specialization, small.gap, big.gap)
small.gap = 0.4
big.gap
create.chord.diagram(healthmap.links.filepath, healthmap.output.filepath, healthmap.legend.filepath, colors.for.group, colors.for.geo.focus, colors.for.specialization, small.gap, big.gap)
create.chord.diagram(padiweb.links.filepath, padiweb.output.filepath, padiweb.legend.filepath,
colors.for.group, colors.for.geo.focus, colors.for.specialization, small.gap,
big.gap)
library("rjson")
library(stacatalogue)
library("gdalcubes")
library("rstac")
library("tibble")
library("sp")
library("rgdal")
library("lubridate")
library("RCurl")
library("sf")
library("dplyr")
library("rgbif")
library("tidyr")
library("stars")
library("ggplot2")
library("raster")
library("terra")
options(timeout = max(60000000, getOption("timeout")))
# Load functions
setwd("C:/GitHub/biab-2.0")
source("/scripts/ClimateMetrics/funcClimateMetrics.R")
source("/scripts/loadObservations/funcLoadObservations.R")
# Load functions
setwd("C:/GitHub/biab-2.0/")
source("/scripts/ClimateMetrics/funcClimateMetrics.R")
getwd()
source("/scripts/ClimateMetrics/funcClimateMetrics.R")
source("/scripts/ClimateMetrics/funcClimateMetrics.R")
source("/scripts/ClimateMetrics/funcClimateMetrics.R")
source("./scripts/ClimateMetrics/funcClimateMetrics.R")
source("./scripts/loadObservations/funcLoadObservations.R")
buffer_box <- 0
obs <- load_observations(species =
"Glyptemys insculpta",
limit = 2000,
database = "gbif",
year_start = 1980,
year_end = 2020)
# Reproject the obs to the data cube projection
obs_pts <-
stacatalogue::project_coords(obs,
lon = "decimal_longitude",
lat = "decimal_latitude",
proj_from = "+proj=longlat +datum=WGS84",
proj_to = "EPSG:6623")
# Create the extent (data cube projection)
bbox <- stacatalogue::points_to_bbox(obs_pts, buffer = buffer_box)
t1 = "1983-12-31"
n_year <- as.integer(substr(input$t0, 1, 4)) - as.integer(substr(input$t1, 1, 4))
temporal_res <- paste0("P", n_year, "Y")
t0 = "1981-01-01"
t1 = "1983-12-31"
n_year <- as.integer(substr(t0, 1, 4)) - as.integer(substr(t1, 1, 4))
temporal_res <- paste0("P", n_year, "Y")
cube_current <- stacatalogue::load_cube(collections = 'chelsa-monthly',
bbox = bbox,
t0 = t0,
t1 = t1,
limit = 5000,
variable = "tas",
spatial.res = 1000, # in meters
temporal.res = temporal_res, # see number of years t0 to t1
aggregation = "mean",
resampling = "bilinear"
)
temporal_res
n_year
n_year <- as.integer(substr(t1, 1, 4)) - as.integer(substr(t0, 1, 4))
n_year
my_vector <- c(xmin = -78, xmax = -77, ymax = 49, ymin = 48)
bbox <- my_vector %>% sf::st_bbox(crs = "EPSG:4326") %>%
sf::st_as_sfc() %>% sf::st_transform(crs = srs_cube) %>%
sf::st_bbox()
bbox <- my_vector %>% sf::st_bbox(crs = "EPSG:4326") %>%
sf::st_as_sfc() %>% sf::st_transform(crs = "EPSG:6623") %>%
sf::st_bbox()
bbox
water_prop <-load_prop_values(stac_path = "https://planetarycomputer.microsoft.com/api/stac/v1/",
collections = c("io-lulc-9-class"),
bbox = bbox,
srs.cube = "EPSG:6623",
limit = 1000,
t0 = "2017-01-01",
t1 = "2017-12-31",
spatial.res = 10, # in meters
prop = F,
prop.res = 1000,
select_values = c(1),
temporal.res =  "P1Y")
load_prop_values
stac_path = "https://planetarycomputer.microsoft.com/api/stac/v1/"
collections = c("io-lulc-9-class")
bbox = bbox
srs.cube = "EPSG:6623"
limit = 1000
t0 = "2017-01-01"
t1 = "2017-12-31"
spatial.res = 10# in meters
prop = F
prop.res = 1000
select_values = c(1)
temporal.res =  "P1Y"
s <- rstac::stac(stac_path)
left <- bbox$xmin
right <- bbox$xmax
bottom <- bbox$ymin
top <- bbox$ymax
if (left > right) {
stop("left and right seem reversed")
}
if (bottom > top) {
stop("bottom and top seem reversed")
}
bbox.wgs84 <- bbox %>% sf::st_bbox(crs = srs.cube) %>% sf::st_as_sfc() %>%
sf::st_transform(crs = "EPSG:4326") %>% sf::st_bbox()
if (!is.null(t0)) {
datetime <- format(lubridate::as_datetime(t0), "%Y-%m-%dT%H:%M:%SZ")
}
if (!is.null(t0)) {
datetime <- format(lubridate::as_datetime(t0), "%Y-%m-%dT%H:%M:%SZ")
} else {
it_obj_tmp <- s %>% rstac::stac_search(bbox = bbox.wgs84,
collections = collections, limit = limit) %>% rstac::get_request()
datetime <- it_obj_tmp$features[[1]]$properties$datetime
t0 <- datetime
t1 <- datetime
}
t0
t1
if (!is.null(t1) && t1 != t0) {
datetime <- paste(datetime, format(lubridate::as_datetime(t1),
"%Y-%m-%dT%H:%M:%SZ"), sep = "/")
}
RCurl::url.exists(stac_path)
it_obj <- s %>% rstac::stac_search(bbox = bbox.wgs84, collections = collections,
datetime = datetime, limit = limit) %>% rstac::get_request()
it_obj
if (is.null(layers)) {
layers <- unlist(lapply(it_obj$features, function(x) {
names(x$assets)
}))
}
layers=NULL
if (is.null(layers)) {
layers <- unlist(lapply(it_obj$features, function(x) {
names(x$assets)
}))
}
v <- gdalcubes::cube_view(srs = srs.cube, extent = list(t0 = t0,
t1 = t1, left = left, right = right, top = top, bottom = bottom),
dx = spatial.res, dy = spatial.res, dt = temporal.res,
aggregation = "mode", resampling = "near")
v
gdalcubes::gdalcubes_options(parallel = T)
cube_class_rstack <- raster::stack()
i=1
layers
it_obj$features
st <- gdalcubes::stac_image_collection(it_obj$features)
names(it_obj$features)
it_obj$features[[1]]$asset
v
it_obj$features
?stac_image_collection
st <- gdalcubes::stac_image_collection(it_obj)
st <- gdalcubes::stac_image_collection(it_obj$features)
st <- gdalcubes::stac_image_collection(it_obj$features$data)
water_prop <-load_cube(stac_path = "https://planetarycomputer.microsoft.com/api/stac/v1/",
collections = c("io-lulc-9-class"),
bbox = bbox,
srs.cube = "EPSG:6623",
limit = 1000,
t0 = "2017-01-01",
t1 = "2017-12-31",
spatial.res = 10, # in meters
temporal.res =  "P1Y")
water_prop
st <- gdalcubes::stac_image_collection(it_obj$features,
asset_names = "data")
cube_class <- gdalcubes::raster_cube(st, v, mask = image_mask(band = "data",
values = 1, invert = T))
cube_class <- cube_class %>% stars::st_as_stars() %>%
as("Raster")
cube_class
plot(cube_class)
t1 = "2018-12-31"
if (!is.null(t0)) {
datetime <- format(lubridate::as_datetime(t0), "%Y-%m-%dT%H:%M:%SZ")
} else {
it_obj_tmp <- s %>% rstac::stac_search(bbox = bbox.wgs84,
collections = collections, limit = limit) %>% rstac::get_request()
datetime <- it_obj_tmp$features[[1]]$properties$datetime
t0 <- datetime
t1 <- datetime
}
if (!is.null(t1) && t1 != t0) {
datetime <- paste(datetime, format(lubridate::as_datetime(t1),
"%Y-%m-%dT%H:%M:%SZ"), sep = "/")
}
RCurl::url.exists(stac_path)
water_prop <-load_cube(stac_path = "https://planetarycomputer.microsoft.com/api/stac/v1/",
collections = c("io-lulc-9-class"),
bbox = bbox,
srs.cube = "EPSG:6623",
limit = 1000,
t0 = "2017-01-01",
t1 = "2018-12-31",
spatial.res = 10, # in meters
temporal.res =  "P1Y")
water_prop
it_obj <- s %>% rstac::stac_search(bbox = bbox.wgs84, collections = collections,
datetime = datetime, limit = limit) %>% rstac::get_request()
v <- gdalcubes::cube_view(srs = srs.cube, extent = list(t0 = t0,
t1 = t1, left = left, right = right, top = top, bottom = bottom),
dx = spatial.res, dy = spatial.res, dt = temporal.res,
aggregation = "mode", resampling = "near")
gdalcubes::gdalcubes_options(parallel = T)
cube_class_rstack <- raster::stack()
st <- gdalcubes::stac_image_collection(it_obj$features,
asset_names = "data")
st
names(st)
st <- gdalcubes::stac_image_collection(it_obj$features,
property_filter = function(x) {
x[["variable"]] == "18T-2017"
})
st <- gdalcubes::stac_image_collection(it_obj$features,
property_filter = function(x) {
x[["name"]] == "18T-2017"
})
?image_mask
cube_class <- gdalcubes::raster_cube(st, v, mask = image_mask(band = "18U-2018",
values = 1, invert = T))
cube_class <- gdalcubes::raster_cube(st, v, mask = image_mask(band = "data",
values = 1, invert = T))
cube_class
cube_class <- cube_class %>% stars::st_as_stars() %>%
as("Raster")
cube_class
cube_class <- raster::calc(cube_class, sum, na.rm = T)
cube_class
cube_class
plot(cube_class)
load_prop_values
load_prop_values = function (stac_path = "https://io.biodiversite-quebec.ca/stac/",
collections = c("esacci-lc"), srs.cube = "EPSG:6623",
t0 = "2000-01-01", t1 = "2001-12-31", spatial.res = 250,
bbox = NULL, limit = 5000, prop = F, prop.res = 1000, select_values = NULL,
layers = NULL, variable = NULL, temporal.res = "P1Y") {
s <- rstac::stac(stac_path)
left <- bbox$xmin
right <- bbox$xmax
bottom <- bbox$ymin
top <- bbox$ymax
if (left > right) {
stop("left and right seem reversed")
}
if (bottom > top) {
stop("bottom and top seem reversed")
}
bbox.wgs84 <- bbox %>% sf::st_bbox(crs = srs.cube) %>% sf::st_as_sfc() %>%
sf::st_transform(crs = "EPSG:4326") %>% sf::st_bbox()
if (!is.null(t0)) {
datetime <- format(lubridate::as_datetime(t0), "%Y-%m-%dT%H:%M:%SZ")
} else {
it_obj_tmp <- s %>% rstac::stac_search(bbox = bbox.wgs84,
collections = collections, limit = limit) %>% rstac::get_request()
datetime <- it_obj_tmp$features[[1]]$properties$datetime
t0 <- datetime
t1 <- datetime
}
if (!is.null(t1) && t1 != t0) {
datetime <- paste(datetime, format(lubridate::as_datetime(t1),
"%Y-%m-%dT%H:%M:%SZ"), sep = "/")
}
RCurl::url.exists(stac_path)
it_obj <- s %>% rstac::stac_search(bbox = bbox.wgs84, collections = collections,
datetime = datetime, limit = limit) %>% rstac::get_request()
if (is.null(spatial.res)) {
name1 <- unlist(lapply(it_obj$features, function(x) {
names(x$assets)
}))[1]
spatial.res <- it_obj$features[[1]]$assets[[name1]]$`raster:bands`[[1]]$spatial_resolution
}
if (is.null(layers)) {
layers <- unlist(lapply(it_obj$features, function(x) {
names(x$assets)
}))
}
v <- gdalcubes::cube_view(srs = srs.cube, extent = list(t0 = t0,
t1 = t1, left = left, right = right, top = top, bottom = bottom),
dx = spatial.res, dy = spatial.res, dt = temporal.res,
aggregation = "mode", resampling = "near")
gdalcubes::gdalcubes_options(parallel = T)
cube_class_rstack <- raster::stack()
for (i in 1:length(unique(select_values))) {
st <- gdalcubes::stac_image_collection(it_obj$features,
asset_names = "data")
cube_class <- gdalcubes::raster_cube(st, v, mask = image_mask(band = "data",
values = select_values[i], invert = T))
if (prop) {
cube_class <- cube_class %>% gdalcubes::aggregate_space(dx = prop.res,
dy = prop.res, method = "count") %>%
stars::st_as_stars() %>% as("Raster")
cube_class <- cube_class/((prop.res/spatial.res)^2)
}
else {
cube_class <- cube_class %>% stars::st_as_stars() %>%
as("Raster")
cube_class <- raster::calc(cube_class, sum, na.rm = T)
}
names(cube_class) <- paste0("class", select_values[i])
cube_class_rstack <- raster::stack(cube_class_rstack,
cube_class)
}
return(cube_class_rstack)
}
water_prop <-load_prop_values(stac_path = "https://planetarycomputer.microsoft.com/api/stac/v1/",
collections = c("io-lulc-9-class"),
bbox = bbox,
srs.cube = "EPSG:6623",
limit = 1000,
t0 = "2017-01-01",
t1 = "2017-12-31",
spatial.res = 10, # in meters
temporal.res =  "P1Y",
prop = F,
prop.res = 1000,
select_values = c(1))
t1 = "2017-12-31"
select_values = c(1)
s <- rstac::stac(stac_path)
left <- bbox$xmin
right <- bbox$xmax
bottom <- bbox$ymin
top <- bbox$ymax
if (left > right) {
stop("left and right seem reversed")
}
if (bottom > top) {
stop("bottom and top seem reversed")
}
bbox.wgs84 <- bbox %>% sf::st_bbox(crs = srs.cube) %>% sf::st_as_sfc() %>%
sf::st_transform(crs = "EPSG:4326") %>% sf::st_bbox()
if (!is.null(t0)) {
datetime <- format(lubridate::as_datetime(t0), "%Y-%m-%dT%H:%M:%SZ")
} else {
it_obj_tmp <- s %>% rstac::stac_search(bbox = bbox.wgs84,
collections = collections, limit = limit) %>% rstac::get_request()
datetime <- it_obj_tmp$features[[1]]$properties$datetime
t0 <- datetime
t1 <- datetime
}
if (!is.null(t1) && t1 != t0) {
datetime <- paste(datetime, format(lubridate::as_datetime(t1),
"%Y-%m-%dT%H:%M:%SZ"), sep = "/")
}
RCurl::url.exists(stac_path)
it_obj <- s %>% rstac::stac_search(bbox = bbox.wgs84, collections = collections,
datetime = datetime, limit = limit) %>% rstac::get_request()
if (is.null(spatial.res)) {
name1 <- unlist(lapply(it_obj$features, function(x) {
names(x$assets)
}))[1]
spatial.res <- it_obj$features[[1]]$assets[[name1]]$`raster:bands`[[1]]$spatial_resolution
}
if (is.null(layers)) {
layers <- unlist(lapply(it_obj$features, function(x) {
names(x$assets)
}))
}
v <- gdalcubes::cube_view(srs = srs.cube, extent = list(t0 = t0,
t1 = t1, left = left, right = right, top = top, bottom = bottom),
dx = spatial.res, dy = spatial.res, dt = temporal.res,
aggregation = "mode", resampling = "near")
gdalcubes::gdalcubes_options(parallel = T)
cube_class_rstack <- raster::stack()
i=1
select_values
st <- gdalcubes::stac_image_collection(it_obj$features,
asset_names = "data")
cube_class <- gdalcubes::raster_cube(st, v, mask = image_mask(band = "data",
values = select_values[i], invert = T))
cube_class <- cube_class %>% stars::st_as_stars() %>%
as("Raster")
names(cube_class) <- paste0("class", select_values[i])
cube_class_rstack <- raster::stack(cube_class_rstack,
cube_class)
load_prop_values = function (stac_path = "https://io.biodiversite-quebec.ca/stac/",
collections = c("esacci-lc"), srs.cube = "EPSG:6623",
t0 = "2000-01-01", t1 = "2001-12-31", spatial.res = 250,
bbox = NULL, limit = 5000, prop = F, prop.res = 1000, select_values = NULL,
layers = NULL, variable = NULL, temporal.res = "P1Y") {
s <- rstac::stac(stac_path)
left <- bbox$xmin
right <- bbox$xmax
bottom <- bbox$ymin
top <- bbox$ymax
if (left > right) {
stop("left and right seem reversed")
}
if (bottom > top) {
stop("bottom and top seem reversed")
}
bbox.wgs84 <- bbox %>% sf::st_bbox(crs = srs.cube) %>% sf::st_as_sfc() %>%
sf::st_transform(crs = "EPSG:4326") %>% sf::st_bbox()
if (!is.null(t0)) {
datetime <- format(lubridate::as_datetime(t0), "%Y-%m-%dT%H:%M:%SZ")
} else {
it_obj_tmp <- s %>% rstac::stac_search(bbox = bbox.wgs84,
collections = collections, limit = limit) %>% rstac::get_request()
datetime <- it_obj_tmp$features[[1]]$properties$datetime
t0 <- datetime
t1 <- datetime
}
if (!is.null(t1) && t1 != t0) {
datetime <- paste(datetime, format(lubridate::as_datetime(t1),
"%Y-%m-%dT%H:%M:%SZ"), sep = "/")
}
RCurl::url.exists(stac_path)
it_obj <- s %>% rstac::stac_search(bbox = bbox.wgs84, collections = collections,
datetime = datetime, limit = limit) %>% rstac::get_request()
if (is.null(spatial.res)) {
name1 <- unlist(lapply(it_obj$features, function(x) {
names(x$assets)
}))[1]
spatial.res <- it_obj$features[[1]]$assets[[name1]]$`raster:bands`[[1]]$spatial_resolution
}
if (is.null(layers)) {
layers <- unlist(lapply(it_obj$features, function(x) {
names(x$assets)
}))
}
v <- gdalcubes::cube_view(srs = srs.cube, extent = list(t0 = t0,
t1 = t1, left = left, right = right, top = top, bottom = bottom),
dx = spatial.res, dy = spatial.res, dt = temporal.res,
aggregation = "mode", resampling = "near")
gdalcubes::gdalcubes_options(parallel = T)
cube_class_rstack <- raster::stack()
for (i in 1:length(unique(select_values))) {
st <- gdalcubes::stac_image_collection(it_obj$features,
asset_names = "data")
cube_class <- gdalcubes::raster_cube(st, v, mask = image_mask(band = "data",
values = select_values[i], invert = T))
if (prop) {
cube_class <- cube_class %>% gdalcubes::aggregate_space(dx = prop.res,
dy = prop.res, method = "count") %>%
stars::st_as_stars() %>% as("Raster")
cube_class <- cube_class/((prop.res/spatial.res)^2)
}
else {
cube_class <- cube_class %>% stars::st_as_stars() %>%
as("Raster")
}
names(cube_class) <- paste0("class", select_values[i])
cube_class_rstack <- raster::stack(cube_class_rstack,
cube_class)
}
return(cube_class_rstack)
}
water_prop <-load_prop_values(stac_path = "https://planetarycomputer.microsoft.com/api/stac/v1/",
collections = c("io-lulc-9-class"),
bbox = bbox,
srs.cube = "EPSG:6623",
limit = 1000,
t0 = "2017-01-01",
t1 = "2017-12-31",
spatial.res = 10, # in meters
prop = F,
prop.res = 1000,
select_values = c(1),
temporal.res =  "P1Y")
water_prop
water_prop <-load_prop_values(stac_path = "https://planetarycomputer.microsoft.com/api/stac/v1/",
collections = c("io-lulc-9-class"),
bbox = bbox,
srs.cube = "EPSG:6623",
limit = 1000,
t0 = "2017-01-01",
t1 = "2017-12-31",
spatial.res = 10, # in meters
prop = T,
prop.res = 1000,
select_values = c(1),
temporal.res =  "P1Y")
